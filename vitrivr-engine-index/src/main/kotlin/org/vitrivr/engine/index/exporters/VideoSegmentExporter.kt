package org.vitrivr.engine.index.exporters

import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.bytedeco.ffmpeg.global.avcodec
import org.bytedeco.ffmpeg.global.avutil
import org.bytedeco.javacv.FFmpegFrameGrabber
import org.bytedeco.javacv.FFmpegFrameRecorder
import org.bytedeco.javacv.FFmpegLogCallback
import org.bytedeco.javacv.Frame
import org.vitrivr.engine.core.context.IndexContext
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.model.retrievable.attributes.time.TimeRangeAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.file.MimeType

private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates for each video segment a cropped video file
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class VideoSegmentExporter : ExporterFactory {

    companion object {
        val SUPPORTED = setOf(MimeType.MP4)
    }

    /**
     * Creates a new [Exporter] instance from this [VideoSegmentExporter].
     *
     * @param name The name of the [Exporter]
     * @param input The [Operator] to acting as an input.
     * @param context The [IndexContext] to use.
     */
    override fun newExporter(name: String, input: Operator<Retrievable>, context: IndexContext): Exporter {
        val mimeType =
            context[name, "mimeType"]?.let {
                try {
                    MimeType.valueOf(it.uppercase())
                } catch (e: java.lang.IllegalArgumentException) {
                    null
                }
            } ?: MimeType.MP4

        logger.debug {
            "Creating new VideoSegmentExporter with mimeType=$mimeType."
        }
        return Instance(input, context,  mimeType, name)
    }

    /** The [Exporter] generated by this [VideoSegmentExporter]. */
    private class Instance(
        override val input: Operator<Retrievable>,
        private val context: IndexContext,
        private val mimeType: MimeType,
        override val name: String
    ) : Exporter {
        init {
            require(mimeType in SUPPORTED) {
                "VideoPreviewExporter only supports image formats JPEG and PNG."
            }
        }


        override fun toFlow(scope: CoroutineScope): Flow<Retrievable> = this.input.toFlow(scope).onEach { retrievable ->
            val source = retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach
            if (source.type == MediaType.VIDEO && retrievable.type == "SEGMENT") {
                val resolvable = this.context.resolver.resolve(retrievable.id, "${this.mimeType.fileExtension}")!!

                // convert to microseconds
                val startTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.startNs!!/1000
                val endTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.endNs!!/1000


                source.newInputStream().use { input ->
                    FFmpegFrameGrabber(input).use { grabber ->
                        grabber.start()
                        val frameRate = grabber.frameRate
                        // time in microseconds from grabber
                        val length = grabber.lengthInTime
                        grabber.videoCodec = avcodec.AV_CODEC_ID_H264
                        grabber.pixelFormat = avutil.AV_PIX_FMT_YUV420P
                        grabber.audioCodec = avcodec.AV_CODEC_ID_AAC
                        grabber.setTimestamp(startTimestamp)


                        val recorder = FFmpegFrameRecorder("D:/vit/out/${retrievable.id}.mp4",  grabber.imageWidth, grabber.imageHeight, grabber.audioChannels)
                        FFmpegLogCallback.set()
                        configureRecorder(recorder, grabber)

                        logger.debug {
                            "Storing video segment for ${retrievable.id} with ${retrievable.type}. Storing it with ${resolvable::class.simpleName}."
                        }
                        try {
                        recorder.start()

                        var frame: Frame
                        while ((grabber.grabFrame().also { frame = it }) != null && grabber.timestamp <= endTimestamp) {
                            recorder.record(frame)
                         }
                        } catch (e: Exception) {
                            logger.error(e) { "Error while recording video segment. ${e.cause.toString()}" }
                        } finally {
                            recorder.stop()
                            recorder.release()
                            recorder.close()
                            grabber.flush()
                            grabber.stop()
                            grabber.release()
                            grabber.close()
                        }
                    }
                }
            }
        }

        /**
         * Configures the [FFmpegFrameRecorder] with the given [FFmpegFrameGrabber]
         **/
        private fun configureRecorder(recorder: FFmpegFrameRecorder, grabber: FFmpegFrameGrabber) {
            recorder.format = "mp4"
            recorder.frameRate = grabber.frameRate
            recorder.videoBitrate = grabber.videoBitrate
            recorder.videoCodec = avcodec.AV_CODEC_ID_H264
            recorder.pixelFormat = avutil.AV_PIX_FMT_YUV420P
            recorder.audioCodec = avcodec.AV_CODEC_ID_AAC
            recorder.audioChannels = grabber.audioChannels
            recorder.sampleRate = grabber.sampleRate
            recorder.audioBitrate = grabber.audioBitrate
            recorder.audioCodec = grabber.audioCodec
        }
    }
}