package org.vitrivr.engine.index.exporters

import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.ProducerScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.withContext
import org.bytedeco.ffmpeg.global.avcodec
import org.bytedeco.ffmpeg.global.avutil
import org.bytedeco.javacpp.PointerScope
import org.bytedeco.javacv.*
import org.vitrivr.engine.core.context.IndexContext
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.model.retrievable.attributes.time.TimeRangeAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.Metadata
import org.vitrivr.engine.core.source.Source
import org.vitrivr.engine.core.source.file.FileSource
import org.vitrivr.engine.core.source.file.MimeType
import java.nio.file.Files
import java.nio.file.Paths
import java.util.*
import java.util.concurrent.TimeUnit

private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates for each video segment a cropped video file
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class VideoSegmentExporter : ExporterFactory {

    companion object {
        val SUPPORTED = setOf(MimeType.MP4)
    }

    /**
     * Creates a new [Exporter] instance from this [VideoSegmentExporter].
     *
     * @param name The name of the [Exporter]
     * @param input The [Operator] to acting as an input.
     * @param context The [IndexContext] to use.
     */
    override fun newExporter(name: String, input: Operator<Retrievable>, context: IndexContext): Exporter {
        val mimeType =
            context[name, "mimeType"]?.let {
                try {
                    MimeType.valueOf(it.uppercase())
                } catch (e: java.lang.IllegalArgumentException) {
                    null
                }
            } ?: MimeType.MP4
        val location = context[name, "location"]?.let { it.lowercase()} ?: throw IllegalArgumentException("No location specified")
        val video = context[name, "video"]?.let { it.lowercase() == "true" } ?: true
        val audio = context[name, "audio"]?.let { it.lowercase() == "true" } ?: true
        val keyFrames = context[name, "keyFrames"]?.let { it.lowercase() == "true" } ?: false
        logger.debug {
            "Creating new VideoSegmentExporter with mimeType=$mimeType."
        }
        return Instance(input, context, mimeType, location, video, audio, keyFrames, name)
    }


    /** The [Exporter] generated by this [VideoSegmentExporter]. */
    private class Instance(
        override val input: Operator<Retrievable>,
        private val context: IndexContext,
        private val mimeType: MimeType,
        private val location: String,
        private val video: Boolean = true,
        private val audio: Boolean = true,
        private val keyFrames: Boolean = false,
        override val name: String
    ) : Exporter {
        init {
            require(mimeType in SUPPORTED) {
                "VideoPreviewExporter only supports image formats JPEG and PNG."
            }
        }
        override fun toFlow(scope: CoroutineScope): Flow<Retrievable> = this.input.toFlow(scope).onEach { retrievable ->

            val source = retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach

            if (source.type != MediaType.VIDEO || retrievable.type != "SEGMENT") {
                logger.debug { "In flow: Skipping source ${source.name} (${source.sourceId}) because it is not of type VIDEO." }
                return@onEach
            }

            val startTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.startNs!! / 1000
            val endTimestamp = retrievable.filteredAttribute(TimeRangeAttribute::class.java)?.endNs!! / 1000
            val resolvable = this.context.resolver.resolve(retrievable.id, this.mimeType.fileExtension)!!
            val path  = "$location/${retrievable.id}/segment.${this.mimeType.fileExtension}"

            if (source is FileSource) {
                FFmpegFrameGrabber(source.path.toFile()).use { grabber ->
                    decodeFromGrabber(source, grabber, path , startTimestamp, endTimestamp)
                    grabber.close()
                }
            } else {
                source.newInputStream().use { input ->
                    FFmpegFrameGrabber(input).use { grabber ->
                        decodeFromGrabber(source, grabber, path , startTimestamp, endTimestamp)
                        grabber.close()
                    }
                }
            }
        }


        /**
         * Decodes a video from a [FFmpegFrameGrabber] and emits [Retrievable] elements to the downstream [channel].
         *
         * @param source The [Source] from which the video is being decoded.
         * @param grabber The [FFmpegFrameGrabber] used to decode the video.
         * @param channel The [ProducerScope] used to emit [Retrievable] elements.
         */
        private suspend fun decodeFromGrabber(
            source: Source,
            grabber: FFmpegFrameGrabber,
            path: String,
            startMs: Long,
            endMs: Long,
        ) {

            /* Configure FFmpegFrameGrabber. */
            grabber.imageMode = FrameGrabber.ImageMode.COLOR
            grabber.sampleMode = FrameGrabber.SampleMode.SHORT
            grabber.setTimestamp(startMs)


            logger.info { "Start recording segment from ${startMs/1000000} to ${endMs/1000000} of source ${source.name} (${source.sourceId})" }
            try {
                grabber.start()
                /* Extract and enrich source metadata. */
                source.metadata[Metadata.METADATA_KEY_VIDEO_FPS] = grabber.videoFrameRate
                source.metadata[Metadata.METADATA_KEY_AV_DURATION] =
                    TimeUnit.MICROSECONDS.toMillis(grabber.lengthInTime)
                source.metadata[Metadata.METADATA_KEY_IMAGE_WIDTH] = grabber.imageWidth
                source.metadata[Metadata.METADATA_KEY_IMAGE_HEIGHT] = grabber.imageHeight
                source.metadata[Metadata.METADATA_KEY_AUDIO_CHANNELS] = grabber.audioChannels
                source.metadata[Metadata.METADATA_KEY_AUDIO_SAMPLERATE] = grabber.sampleRate
                source.metadata[Metadata.METADATA_KEY_AUDIO_SAMPLESIZE] = grabber.sampleFormat

                withContext(Dispatchers.IO) {
                    Files.createDirectories(Paths.get(path).parent)
                }

                val recorder = FFmpegFrameRecorder(
                    path,
                    grabber.imageWidth,
                    grabber.imageHeight,
                    grabber.audioChannels
                )
                try {
                    recorder.start()
                    configureRecorder(recorder, grabber)

                    do {
                        val frame =
                            grabber.grabFrame(
                                this@Instance.audio,
                                this@Instance.video,
                                true,
                                this@Instance.keyFrames,
                                true
                            ) ?: break

                        if (grabber.timestamp >= endMs) {
                            break
                        }

                        when (frame.type) {
                            Frame.Type.VIDEO -> {
                                try {
                                    PointerScope().use { scope -> recorder.record(frame) }
                                } catch (e: Exception) {
                                    logger.error(e) { "Error converting frame to BufferedImage" }
                                }
                            }

                            Frame.Type.AUDIO -> {
                                try {
                                    PointerScope().use { scope -> recorder.record(frame) }
                                } catch (e: Exception) {
                                    logger.error(e) { "Error converting frame to BufferedImage" }
                                }
                            }

                            else -> { /* No op. */
                            }
                        }
                    } while (true)
                } catch (e: Exception) {
                    logger.error(e) { "Error while recording video segment. ${e.cause.toString()}" }
                } finally {
                    recorder.stop()
                }
                logger.info { "Finished decoding video from source '${source.name}' (${source.sourceId}):" }
            } catch (exception: Exception) {
                logger.error(exception) { "Failed to decode video from source '${source.name}' (${source.sourceId})." }
            } finally {
                grabber.stop()
            }
        }

        /**
         * Configures the [FFmpegFrameRecorder] with the given [FFmpegFrameGrabber]
         **/
        private fun configureRecorder(recorder: FFmpegFrameRecorder, grabber: FFmpegFrameGrabber) {
            recorder.format = "mp4"
            recorder.frameRate = grabber.frameRate
            recorder.videoBitrate = grabber.videoBitrate
            recorder.videoCodec = avcodec.AV_CODEC_ID_H264
            recorder.pixelFormat = avutil.AV_PIX_FMT_YUV420P
            recorder.audioCodec = avcodec.AV_CODEC_ID_AAC
            recorder.audioChannels = grabber.audioChannels
            recorder.sampleRate = grabber.sampleRate
            recorder.audioBitrate = grabber.audioBitrate
            recorder.audioCodec = grabber.audioCodec
        }
    }
}