package org.vitrivr.engine.index.exporters

import com.sksamuel.scrimage.ImmutableImage
import com.sksamuel.scrimage.nio.JpegWriter
import com.sksamuel.scrimage.nio.PngWriter
import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import java.awt.image.BufferedImage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.bytedeco.javacv.FFmpegFrameGrabber
import org.bytedeco.javacv.Java2DFrameConverter
import org.vitrivr.engine.core.context.IndexContext
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.source.file.FileSource
import org.vitrivr.engine.core.source.file.MimeType
import java.io.InputStream

private val logger: KLogger = KotlinLogging.logger {}

/**  */
/**
 * An [Exporter] that generates a single preview of a video at the parameterized timestamp.
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class VideoPreviewExporter : ExporterFactory {
  companion object {
    val SUPPORTED = setOf(MimeType.JPEG, MimeType.JPG, MimeType.PNG)
  }

  /**
   * Creates a new [Exporter] instance from this [VideoPreviewExporter].
   *
   * @param name The name of the [Exporter]
   * @param input The [Operator] to acting as an input.
   * @param context The [IndexContext] to use.
   */
  override fun newExporter(
      name: String,
      input: Operator<Retrievable>,
      context: IndexContext
  ): Exporter {
    val maxSideResolution = context[name, "maxSideResolution"]?.toIntOrNull() ?: 400
    val mimeType =
        context[name, "mimeType"]?.let {
          try {
            MimeType.valueOf(it.uppercase())
          } catch (e: java.lang.IllegalArgumentException) {
            null
          }
        } ?: MimeType.JPG
    val previewTimeSec = context[name, "previewTimeSec"]?.toIntOrNull() ?: 5
    logger.debug {
      "Creating new VideoPreviewExporter with maxSideResolution=$maxSideResolution mimeType=$mimeType, and previewTimeSec=$previewTimeSec."
    }
    return Instance(input, context, maxSideResolution, mimeType, previewTimeSec)
  }

  /** The [Exporter] generated by this [VideoPreviewExporter]. */
  private class Instance(
      override val input: Operator<Retrievable>,
      private val context: IndexContext,
      private val maxResolution: Int,
      private val mimeType: MimeType,
      private val previewTimeSec: Int
  ) : Exporter {
    init {
      require(mimeType in SUPPORTED) {
        "VideoPreviewExporter only supports image formats JPEG and PNG."
      }
    }

    override fun toFlow(scope: CoroutineScope): Flow<Retrievable> =
        this.input.toFlow(scope).onEach { retrievable ->
          val resolvable = this.context.resolver.resolve(retrievable.id)
          if (retrievable.type.equals("SOURCE:VIDEO")) {

            if (resolvable != null) {
              val writer =
                  when (mimeType) {
                    MimeType.JPEG,
                    MimeType.JPG -> JpegWriter()
                    MimeType.PNG -> PngWriter()
                    else -> throw IllegalArgumentException("Unsupported mime type $mimeType")
                  }

              logger.debug {
                "Generating preview thumbnail for ${retrievable.id} with ${retrievable.type} and resolution $maxResolution. Storing it with ${resolvable::class.simpleName}."
              }

              println(previewTimeSec)
              val source =
                  (retrievable.filteredAttribute(SourceAttribute::class.java)?.source)?.newInputStream()
              val frame = source?.let { getFrameAtSecond(it, previewTimeSec) }
              val imgBytes =
                  ImmutableImage.fromAwt(frame)
                      .let {
                        if (it.width > it.height) {
                          it.scaleToWidth(maxResolution)
                        } else {
                          it.scaleToHeight(maxResolution)
                        }
                      }
                      .bytes(writer)

              resolvable.openOutputStream().use { it.write(imgBytes) }
            }
          }
        }

    /**
     * Extracts a frame from the video at the specified second.
     *
     * @param videoFilePath The path to the video file.
     * @param second The second at which to extract the frame.
     * @return The extracted frame as a BufferedImage.
     */
    private fun getFrameAtSecond(input: InputStream, second: Int): BufferedImage {
      FFmpegFrameGrabber(input).use { grabber ->
        grabber.start()
        val frameRate = grabber.frameRate
        grabber.frameNumber = (frameRate * second).toInt()

        val frame = grabber.grabImage()
        grabber.stop()

        return Java2DFrameConverter().convert(frame)
      }
    }
  }
}
