package org.vitrivr.engine.model3d

import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import java.awt.Color
import java.awt.image.BufferedImage
import java.awt.image.DataBufferInt
import java.util.*
import javax.imageio.ImageIO
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.joml.Vector3f
import org.vitrivr.engine.core.context.IndexContext
import org.vitrivr.engine.core.model.mesh.texturemodel.Model
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.file.MimeType
import org.vitrivr.engine.model3d.data.render.lwjgl.render.RenderOptions
import org.vitrivr.engine.model3d.data.render.lwjgl.renderer.RenderJob
import org.vitrivr.engine.model3d.data.render.lwjgl.renderer.RenderWorker
import org.vitrivr.engine.model3d.data.render.lwjgl.window.WindowOptions
import org.vitrivr.engine.model3d.data.util.texturemodel.entropyoptimizer.ModelEntropyOptimizer
import org.vitrivr.engine.model3d.texturemodel.util.entropyoptimizer.EntopyCalculationMethod
import org.vitrivr.engine.model3d.texturemodel.util.entropyoptimizer.EntropyOptimizerStrategy
import org.vitrivr.engine.model3d.texturemodel.util.entropyoptimizer.OptimizerOptions

private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates a preview of a 3d model.
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class ModelPreviewExporter : ExporterFactory {
  companion object {
    val SUPPORTED = setOf(MimeType.GLTF)
  }

  /**
   * Creates a new [Exporter] instance from this [ModelPreviewExporter].
   *
   * @param name The name of the [Exporter]
   * @param input The [Operator] to acting as an input.
   * @param context The [IndexContext] to use.
   */
  override fun newExporter(
      name: String,
      input: Operator<Retrievable>,
      context: IndexContext
  ): Exporter {
    val maxSideResolution = context[name, "maxSideResolution"]?.toIntOrNull() ?: 800
    val mimeType =
        context[name, "mimeType"]?.let {
          try {
            MimeType.valueOf(it.uppercase())
          } catch (e: java.lang.IllegalArgumentException) {
            null
          }
        } ?: MimeType.GLTF
    val distance = context[name, "distance"]?.toFloatOrNull() ?: 1f

    logger.debug {
      "Creating new ModelPreviewExporter with maxSideResolution=$maxSideResolution and mimeType=$mimeType"
    }
    return Instance(input, context, maxSideResolution, mimeType, distance)
  }

  /** The [Exporter] generated by this [ModelPreviewExporter]. */
  private class Instance(
      override val input: Operator<Retrievable>,
      private val context: IndexContext,
      private val maxResolution: Int,
      private val mimeType: MimeType,
      private val distance: Float
  ) : Exporter {
    init {
      require(mimeType in SUPPORTED) { "ModelPreviewExporter only supports models of format GLTF." }
    }

    override fun toFlow(scope: CoroutineScope): Flow<Retrievable> =
        this.input.toFlow(scope).onEach { retrievable ->
          val source =
              retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach
          if (source.type == MediaType.MESH) {
            val resolvable = this.context.resolver.resolve(retrievable.id)

            val model = retrievable.content[0].content as Model
            if (resolvable != null) {
              logger.debug {
                "Generating preview for ${retrievable.id} with ${retrievable.type} and resolution $maxResolution. Storing it with ${resolvable::class.simpleName}."
              }

              source.newInputStream().use { input ->
                val preview2: BufferedImage = createPreview(model)

                resolvable.openOutputStream().use { output ->
                  ImageIO.write(preview2, "png", output) // Use appropriate format (e.g., "png")
                }
              }
            }
          }
        }

    fun createPreview(model: Model): BufferedImage {
      if (model.modelMaterials.isNotEmpty()) {
        // Set options for the renderer.
        val windowOptions =
            object : WindowOptions(400, 400) {
              init {
                hideWindow = false
              }
            }
        val renderOptions =
            object : RenderOptions() {
              init {
                showTextures = true
              }
            }

        // Set options for the entropy optimizer.
        val opts =
            object : OptimizerOptions() {
              init {
                iterations = 100
                initialViewVector = Vector3f(0f, 0f, 1f)
                method = EntopyCalculationMethod.RELATIVE_TO_TOTAL_AREA_WEIGHTED
                optimizer = EntropyOptimizerStrategy.RANDOMIZED
                yNegWeight = 0.7f
                yPosWeight = 0.8f
              }
            }

        // Define camera positions
        val cameraPositions = LinkedList<Vector3f>()
        cameraPositions.add(
            Vector3f(
                    (Math.random() - 0.5).toFloat() * 2f,
                    (Math.random() - 0.5).toFloat() * 2f,
                    (Math.random() - 0.5).toFloat() * 2f)
                .normalize()
                .mul(distance))
        cameraPositions.add(Vector3f(0f, 0f, 1f).normalize().mul(distance))
        cameraPositions.add(Vector3f(-1f, 1f, 1f).normalize().mul(distance))
        cameraPositions.add(ModelEntropyOptimizer.getViewVectorWithMaximizedEntropy(model, opts))

        // Render the model.
        // TODO CRASH IS HAPPENING HERE
        val images =
            RenderJob.performStandardRenderJob(
                RenderWorker.getRenderJobQueue(),
                model,
                cameraPositions,
                windowOptions,
                renderOptions)

        assert(images.size == 4)

        val combinedImage = BufferedImage(800, 800, BufferedImage.TYPE_INT_RGB)
        val combinedData = (combinedImage.raster.dataBuffer as DataBufferInt).data

        val img1Data = (images[0].raster.dataBuffer as DataBufferInt).data
        val img2Data = (images[1].raster.dataBuffer as DataBufferInt).data
        val img3Data = (images[2].raster.dataBuffer as DataBufferInt).data
        val img4Data = (images[3].raster.dataBuffer as DataBufferInt).data

        val imgSize: Int = images[0].width

        fun copyImageData(
            srcData: IntArray,
            srcOffsetX: Int,
            srcOffsetY: Int,
            dstOffsetX: Int,
            dstOffsetY: Int
        ) {
          for (y in 0 until imgSize) {
            for (x in 0 until imgSize) {
              combinedData[(dstOffsetY + y) * 800 + (dstOffsetX + x)] =
                  srcData[(srcOffsetY + y) * imgSize + (srcOffsetX + x)]
            }
          }
        }

        // Copy images to their respective corners
        copyImageData(img1Data, 0, 0, 0, 0) // Top-left corner
        copyImageData(img2Data, 0, 0, imgSize, 0) // Top-right corner
        copyImageData(img3Data, 0, 0, 0, imgSize) // Bottom-left corner
        copyImageData(img4Data, 0, 0, imgSize, imgSize) // Bottom-right corner

        // Write the combined image to file.
        return combinedImage
      }
      return BufferedImage(800, 800, BufferedImage.TYPE_INT_RGB).apply {
        graphics.apply {
          color = Color.RED
          fillRect(0, 0, 800, 800)
        }
      }
    }
  }
}
