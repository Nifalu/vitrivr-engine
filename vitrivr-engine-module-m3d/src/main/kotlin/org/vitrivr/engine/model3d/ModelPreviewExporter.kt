package org.vitrivr.engine.model3d

import io.github.oshai.kotlinlogging.KLogger
import io.github.oshai.kotlinlogging.KotlinLogging
import java.awt.image.BufferedImage
import java.awt.image.DataBufferInt
import java.io.ByteArrayOutputStream
import java.util.*
import javax.imageio.*
import javax.imageio.metadata.IIOMetadata
import javax.imageio.metadata.IIOMetadataNode
import javax.imageio.stream.MemoryCacheImageOutputStream
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.onEach
import org.joml.Vector3f
import org.vitrivr.engine.core.context.IndexContext
import org.vitrivr.engine.core.model.mesh.texturemodel.Model
import org.vitrivr.engine.core.model.mesh.texturemodel.util.entropyoptimizer.EntopyCalculationMethod
import org.vitrivr.engine.core.model.mesh.texturemodel.util.entropyoptimizer.EntropyOptimizerStrategy
import org.vitrivr.engine.core.model.mesh.texturemodel.util.entropyoptimizer.OptimizerOptions
import org.vitrivr.engine.core.model.retrievable.Retrievable
import org.vitrivr.engine.core.model.retrievable.attributes.SourceAttribute
import org.vitrivr.engine.core.operators.Operator
import org.vitrivr.engine.core.operators.general.Exporter
import org.vitrivr.engine.core.operators.general.ExporterFactory
import org.vitrivr.engine.core.source.MediaType
import org.vitrivr.engine.core.source.file.MimeType
import org.vitrivr.engine.model3d.data.render.lwjgl.render.RenderOptions
import org.vitrivr.engine.model3d.data.render.lwjgl.renderer.RenderJob
import org.vitrivr.engine.model3d.data.render.lwjgl.renderer.RenderWorker
import org.vitrivr.engine.model3d.data.render.lwjgl.window.WindowOptions
import org.vitrivr.engine.model3d.data.util.texturemodel.entropyoptimizer.ModelEntropyOptimizer

private val logger: KLogger = KotlinLogging.logger {}

/**
 * An [Exporter] that generates a preview of a 3d model.
 *
 * @author Rahel Arnold
 * @version 2.1.0
 */
class ModelPreviewExporter : ExporterFactory {
  companion object {
    val SUPPORTED = setOf(MimeType.GLTF)
    val FORMAT = setOf("gif", "jpg")
  }

  /**
   * Creates a new [Exporter] instance from this [ModelPreviewExporter].
   *
   * @param name The name of the [Exporter]
   * @param input The [Operator] to acting as an input.
   * @param context The [IndexContext] to use.
   */
  override fun newExporter(
      name: String,
      input: Operator<Retrievable>,
      context: IndexContext
  ): Exporter {
    val maxSideResolution = context[name, "maxSideResolution"]?.toIntOrNull() ?: 800
    val mimeType =
        context[name, "mimeType"]?.let {
          try {
            MimeType.valueOf(it.uppercase())
          } catch (e: java.lang.IllegalArgumentException) {
            null
          }
        } ?: MimeType.GLTF
    val distance = context[name, "distance"]?.toFloatOrNull() ?: 1f
    val format = context[name, "format"] ?: "gif"
    val views = context[name, "views"]?.toIntOrNull() ?: 30

    logger.debug {
      "Creating new ModelPreviewExporter with maxSideResolution=$maxSideResolution and mimeType=$mimeType"
    }
    return Instance(input, context, maxSideResolution, mimeType, distance, format, views)
  }

  /** The [Exporter] generated by this [ModelPreviewExporter]. */
  private class Instance(
      override val input: Operator<Retrievable>,
      private val context: IndexContext,
      private val maxResolution: Int,
      mimeType: MimeType,
      private val distance: Float,
      private val format: String,
      private val views: Int
  ) : Exporter {
    init {
      require(mimeType in SUPPORTED) { "ModelPreviewExporter only supports models of format GLTF." }
      require(format in FORMAT) { "ModelPreviewExporter only supports exporting a gif of jpg." }
    }

    override fun toFlow(scope: CoroutineScope): Flow<Retrievable> =
        this.input.toFlow(scope).onEach { retrievable ->
          val source =
              retrievable.filteredAttribute(SourceAttribute::class.java)?.source ?: return@onEach
          if (source.type == MediaType.MESH) {
            val resolvable = this.context.resolver.resolve(retrievable.id)

            val model = retrievable.content[0].content as Model
            if (resolvable != null) {
              logger.debug {
                "Generating preview for ${retrievable.id} with ${retrievable.type} and resolution $maxResolution. Storing it with ${resolvable::class.simpleName}."
              }

              source.newInputStream().use { input ->
                if (format == "jpg") {
                  val preview: BufferedImage = createPreviewJPG(model)
                  resolvable.openOutputStream().use { output ->
                    ImageIO.write(preview, "jpg", output)
                  }
                } else { // format == "gif"
                  val frames = createFramesForGif(model, views)
                  val gif = createGif(frames, 50)
                  resolvable.openOutputStream().use {
                      output -> output.write(gif!!.toByteArray()) }
                }
              }
            }
          }
        }

    fun createPreviewJPG(model: Model): BufferedImage {
      if (model.modelMaterials.isNotEmpty()) {
        // Set options for the renderer.
        val windowOptions =
            object : WindowOptions(400, 400) {
              init {
                hideWindow = false
              }
            }
        val renderOptions =
            object : RenderOptions() {
              init {
                showTextures = true
              }
            }

        // Set options for the entropy optimizer.
        val opts =
            object : OptimizerOptions() {
              init {
                iterations = 100
                initialViewVector = Vector3f(0f, 0f, 1f)
                method = EntopyCalculationMethod.RELATIVE_TO_TOTAL_AREA_WEIGHTED
                optimizer = EntropyOptimizerStrategy.RANDOMIZED
                yNegWeight = 0.7f
                yPosWeight = 0.8f
              }
            }

        // Define camera positions
        val cameraPositions = LinkedList<Vector3f>()
        cameraPositions.add(
            Vector3f(
                    (Math.random() - 0.5).toFloat() * 2f,
                    (Math.random() - 0.5).toFloat() * 2f,
                    (Math.random() - 0.5).toFloat() * 2f)
                .normalize()
                .mul(distance))
        cameraPositions.add(Vector3f(0f, 0f, 1f).normalize().mul(distance))
        cameraPositions.add(Vector3f(-1f, 1f, 1f).normalize().mul(distance))
        cameraPositions.add(ModelEntropyOptimizer.getViewVectorWithMaximizedEntropy(model, opts))

        // Render the model.
        val images =
            RenderJob.performStandardRenderJob(
                RenderWorker.getRenderJobQueue(),
                model,
                cameraPositions,
                windowOptions,
                renderOptions)

        assert(images.size == 4)

        val combinedImage = BufferedImage(800, 800, BufferedImage.TYPE_INT_RGB)
        val combinedData = (combinedImage.raster.dataBuffer as DataBufferInt).data

        val img1Data = (images[0].raster.dataBuffer as DataBufferInt).data
        val img2Data = (images[1].raster.dataBuffer as DataBufferInt).data
        val img3Data = (images[2].raster.dataBuffer as DataBufferInt).data
        val img4Data = (images[3].raster.dataBuffer as DataBufferInt).data

        val imgSize: Int = images[0].width

        fun copyImageData(
            srcData: IntArray,
            srcOffsetX: Int,
            srcOffsetY: Int,
            dstOffsetX: Int,
            dstOffsetY: Int
        ) {
          for (y in 0 until imgSize) {
            for (x in 0 until imgSize) {
              combinedData[(dstOffsetY + y) * 800 + (dstOffsetX + x)] =
                  srcData[(srcOffsetY + y) * imgSize + (srcOffsetX + x)]
            }
          }
        }

        // Copy images to their respective corners
        copyImageData(img1Data, 0, 0, 0, 0) // Top-left corner
        copyImageData(img2Data, 0, 0, imgSize, 0) // Top-right corner
        copyImageData(img3Data, 0, 0, 0, imgSize) // Bottom-left corner
        copyImageData(img4Data, 0, 0, imgSize, imgSize) // Bottom-right corner
        return combinedImage
      }

      throw IllegalArgumentException("Model has no materials.")
    }

    fun createFramesForGif(model: Model, views: Int): List<BufferedImage> {
      if (model.modelMaterials.isNotEmpty()) {
        // Set options for the renderer.
        val windowOptions =
            object : WindowOptions(400, 400) {
              init {
                hideWindow = false
              }
            }
        val renderOptions =
            object : RenderOptions() {
              init {
                showTextures = true
              }
            }

        // Define camera positions depending on the number of views.
        val camera = generateCameraPositions(views, distance)
        val images =
            RenderJob.performStandardRenderJob(
                RenderWorker.getRenderJobQueue(), model, camera, windowOptions, renderOptions)

        assert(images.size == views)
        return images
      }
      throw IllegalArgumentException("Model has no materials.")
    }

    fun generateCameraPositions(numViews: Int, distance: Float): LinkedList<Vector3f> {
      val cameraPositions = LinkedList<Vector3f>()
      val goldenAngle = Math.PI * (3 - sqrt(5.0)) // Golden angle in radians

      for (i in 0 until numViews) {
        val y = 1 - (i / (numViews - 1.0)) * 2 // y goes from 1 to -1
        val radius = sqrt(1 - y * y) // radius at y

        val theta = goldenAngle * i // angle increment

        val x = (cos(theta) * radius).toFloat()
        val z = (sin(theta) * radius).toFloat()
        cameraPositions.add(Vector3f(x, y.toFloat(), z).normalize().mul(distance))
      }

      return cameraPositions
    }

    fun createGif(frames: List<BufferedImage>, delayTimeMs: Int): ByteArrayOutputStream? {
      if (frames.isEmpty()) {
        println("No frames to write to GIF.")
        return null
      }

      try {
        val byteArrayOutputStream = ByteArrayOutputStream()
        val outputImageStream = MemoryCacheImageOutputStream(byteArrayOutputStream)
        val gifWriter: ImageWriter? = ImageIO.getImageWritersBySuffix("gif").next()

        if (gifWriter != null) {
          gifWriter.output = outputImageStream
          gifWriter.prepareWriteSequence(null)

          val param: ImageWriteParam = gifWriter.defaultWriteParam
          param.compressionMode = ImageWriteParam.MODE_EXPLICIT

          val delayTime = (delayTimeMs).toString()

          for ((index, frame) in frames.withIndex()) {
            val image = IIOImage(frame, null, getMetadata(gifWriter, delayTime))
            gifWriter.writeToSequence(image, param)
            //println("Added frame ${index + 1} to GIF.")
          }

          gifWriter.endWriteSequence()
          outputImageStream.close()
          gifWriter.dispose()

          // println("GIF created successfully.")
          return byteArrayOutputStream
        } else {
          println("Failed to create GIF writer.")
        }
      } catch (e: Exception) {
        e.printStackTrace()
      }
      return null
    }

    fun completeGifWriting(gifWriter: ImageWriter?) {
      gifWriter?.endWriteSequence()
      gifWriter?.dispose()
    }

    private fun getMetadata(gifWriter: ImageWriter, delayTime: String): IIOMetadata {
      val imageType = ImageTypeSpecifier.createFromBufferedImageType(BufferedImage.TYPE_INT_RGB)
      val metadata = gifWriter.getDefaultImageMetadata(imageType, null)
      val metaFormatName = metadata.nativeMetadataFormatName

      val root = IIOMetadataNode(metaFormatName)
      val graphicsControlExtensionNode = IIOMetadataNode("GraphicControlExtension")

      graphicsControlExtensionNode.setAttribute("disposalMethod", "none")
      graphicsControlExtensionNode.setAttribute("userInputFlag", "FALSE")
      graphicsControlExtensionNode.setAttribute("transparentColorFlag", "FALSE")
      graphicsControlExtensionNode.setAttribute("delayTime", delayTime)
      graphicsControlExtensionNode.setAttribute("transparentColorIndex", "0")

      root.appendChild(graphicsControlExtensionNode)

      val appExtensionsNode = IIOMetadataNode("ApplicationExtensions")
      val appExtensionNode = IIOMetadataNode("ApplicationExtension")

      appExtensionNode.setAttribute("applicationID", "NETSCAPE")
      appExtensionNode.setAttribute("authenticationCode", "2.0")
      appExtensionNode.userObject = byteArrayOf(0x1, 0x0, 0x0)

      appExtensionsNode.appendChild(appExtensionNode)
      root.appendChild(appExtensionsNode)

      metadata.mergeTree(metaFormatName, root)

      return metadata
    }
  }
}
